如果是暴力枚举每个子数组的话，共有 1 + 2 + ... + n 共 (1 + n) * n / 2 共 n 种情况
根据子数组的最大特点：**连续** 来优化
1. 双指针 / 滑动窗口
双指针只需要维护左右边界状态，滑动窗口需要维护窗口内所有元素的状态。
其中 left/right 的转移一般在 right 满足/不满足后，收缩 left 去求最值，通常适用于求最大/最小值等情况，但不适合统计个数。因为当 left/right 不符合的时候，left+1/right 可能符合，这种情况下因为不符合所以不会看 left + 1 从而导致少统计。
例如
  求中间的连续数组每个比特位的1的个数 >= 1 的最长数组长度 => 滑动窗口维护中间连续数组的个数，一旦不符合就缩小 left 

2. 哈希表 + 前缀和思想
通过 当前sum - 之前的某个sum 来获取符合条件的区间

3. 正难则反：中间的连续数组 = 总的 - 两边
例如 
  求中间的连续数组的最大值/最小值 => 数组和 - 两边相加的最小值/最大值。
  求中间的连续数组的异或值为 0 的子数组个数 => 根据 中间的连续数组的异或值 ^ 左边的异或值 ^ 右边的异或值 === 数组的异或值，可得 0 ^ 左边的异或值 ^ 右边的异或值 === 数组的异或值，即 左边的异或值 ^ 右边的异或值 === 数组的异或值

这样通过枚举两边的长度情况复杂度还是 O(n)

